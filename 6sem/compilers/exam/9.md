### Нисходящий синтаксический анализ. LL(1)-грамматики. Предиктивный синтаксический анализ, управляемый таблицей.

#### Нисходящий синтаксический анализ

**Нисходящий синтаксический анализ** (Top-Down Parsing) строит дерево разбора от корня к листьям, начиная с стартового символа грамматики и последовательно сопоставляя его продукцию с токенами входной строки. Этот метод удобен для создания синтаксических анализаторов, так как его легко реализовать и понять.

#### LL(1)-грамматики

**LL(1)-грамматики** — это подмножество контекстно-свободных грамматик, которые можно распознавать с помощью нисходящего анализа без возвратов (backtracking). "LL" обозначает "слева направо" (Left-to-right) разбор и "левое порождение" (Leftmost derivation), а "1" означает, что анализатор принимает решение, глядя на один токен вперед.

##### Условия для LL(1)-грамматики:
1. **Отсутствие левой рекурсии**: LL(1)-грамматика не должна содержать левой рекурсии.
2. **Левая факторизация**: LL(1)-грамматика не должна содержать альтернативных правил, начинающихся с одного и того же символа.

##### Пример LL(1)-грамматики:
```
E -> T E'
E' -> + T E' | ε
T -> F T'
T' -> * F T' | ε
F -> ( E ) | id
```

#### Предиктивный синтаксический анализ, управляемый таблицей

**Предиктивный синтаксический анализ, управляемый таблицей** (Table-Driven Predictive Parsing) — это метод LL(1)-анализа, в котором используется таблица синтаксического анализа (Parsing Table) для принятия решений о разборе. Таблица определяет, какую продукцию грамматики применять, исходя из текущего состояния и текущего символа входной строки.

##### Основные компоненты предиктивного анализатора:
1. **Стек**: хранит состояния и символы, необходимые для разбора.
2. **Вход**: последовательность токенов, представляющих исходный код.
3. **Таблица синтаксического анализа**: двумерная таблица, строки которой соответствуют нетерминалам, а столбцы — символам входного алфавита (токенам).

##### Пример таблицы синтаксического анализа:
Для грамматики:
```
E -> T E'
E' -> + T E' | ε
T -> F T'
T' -> * F T' | ε
F -> ( E ) | id
```
Таблица синтаксического анализа будет выглядеть так:

|   | id  | +   | *   | (   | )   | $   |
|---|-----|-----|-----|-----|-----|-----|
| E | E -> TE' |     |     | E -> TE' |     |     |
| E'|     | E' -> +TE'|     |     | E' -> ε | E' -> ε |
| T | T -> FT' |     |     | T -> FT' |     |     |
| T'|     | T' -> ε  | T' -> *FT'|     | T' -> ε | T' -> ε |
| F | F -> id  |     |     | F -> (E)|     |     |

##### Алгоритм работы предиктивного анализатора:
1. Инициализация стека: в стек помещается стартовый символ грамматики и символ конца входа `$`.
2. Чтение текущего символа входной строки.
3. Сравнение вершины стека с текущим символом:
    - Если они совпадают, символ удаляется из стека, и входной символ потребляется (переход к следующему символу).
    - Если вершина стека — нетерминал, используется таблица синтаксического анализа для выбора правила продукции. Продукция заменяет нетерминал на стеке.
    - Если нет совпадения и нетерминал не найден в таблице, происходит ошибка синтаксического анализа.
4. Повторение шагов 2-3 до тех пор, пока стек не опустеет или не будет обнаружена ошибка.

##### Пример работы анализатора:
Для входной строки `id + id * id`:
```
1. Стек: E$, Вход: id + id * id$
2. E -> TE', Стек: TE'$, Вход: id + id * id$
3. T -> FT', Стек: FT'E'$, Вход: id + id * id$
4. F -> id, Стек: idT'E'$, Вход: id + id * id$
5. Совпадение id, Стек: T'E'$, Вход: + id * id$
6. T' -> ε, Стек: E'$, Вход: + id * id$
7. E' -> +TE', Стек: +TE'$, Вход: + id * id$
8. Совпадение +, Стек: TE'$, Вход: id * id$
9. T -> FT', Стек: FT'E'$, Вход: id * id$
10. F -> id, Стек: idT'E'$, Вход: id * id$
11. Совпадение id, Стек: T'E'$, Вход: * id$
12. T' -> *FT', Стек: *FT'E'$, Вход: * id$
13. Совпадение *, Стек: FT'E'$, Вход: id$
14. F -> id, Стек: idT'E'$, Вход: id$
15. Совпадение id, Стек: T'E'$, Вход: $
16. T' -> ε, Стек: E'$, Вход: $
17. E' -> ε, Стек: $, Вход: $
18. Успешный разбор
```

### Заключение

Нисходящий синтаксический анализ, особенно предиктивный синтаксический анализ, управляемый таблицей, предоставляет эффективный и понятный метод разбора для LL(1)-грамматик. Эти грамматики легко анализируются без необходимости возвратов, что упрощает процесс создания компиляторов и интерпретаторов.
